# Setting up listenable pulse sink.

```
# Find currently active default output.
# This will be the sink for the module-in-the-middle.
pacmd list-sinks | grep -A1 "* index"
DEFAULT_OUTPUT=$(pacmd list-sinks | grep -A1 "* index" | grep -oP "<\K[^ >]+")
echo $DEFAULT_OUTPUT

# Create a sink that pipes stuff through to `$DEFAULT_OUTPUT`
# while allowing `tee`-like data flow forking.
pactl load-module module-combine-sink \
  sink_name=record-n-play slaves=$DEFAULT_OUTPUT \
  sink_properties=device.description="Record-and-Play"
```

# Compiling shader-oscilloscope

```
gcc -std=c11 sdl_oscilloscope.c `sdl2-config --libs --cflags` -lGL -Wall
```

# Running

```
# Listen to this new sink.
# You'll need to set apps to actually write to this sink.
# The output is binary `--format`. `float32le` works for me.
# `u8` is fine too, but has much less resolution.
parec --raw --format=float32le -d record-n-play.monitor | ./a.out
```

# Audacity

The project contains an audacity project for a demo, just
load it up and hit run-in-loop.
This data has been generated by a LISP (nyquist) script (and manually
post-processed the stuff which i did not manage to get into LISP).
To "run" this script you need to select a new, preferably empty (will be
overwritten) audio track (mono?) and hit "Tools->Open Nyquist Prompt". You'll
get a LISP input window where you can put that code.
