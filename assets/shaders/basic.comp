#version 450

/* #extension GL_NV_gpu_shader5 : enable */
/* #extension GL_ARB_gpu_shader_int64 : enable */

// uvec3 gl_NumWorkGroups; // global work group size we gave to glDispatchCompute() = window / 8
// uvec3 gl_WorkGroupSize; // local work group size we defined with layout = 8
// uvec3 gl_WorkGroupID; // position of current invocation in global work group =
// uvec3 gl_LocalInvocationID; // position of current invocation in local work group =
// uvec3 gl_GlobalInvocationID; // unique index of current invocation in global work group =

/* UNIFORMS */

// Define a work group size to be 1x1.
layout(local_size_x = 8, local_size_y = 8) in;

// Use the image2D sampler to address specific pixels directly.
layout(rgba32f, binding = 0) uniform image2D present;
layout(rgba32f, binding = 1) uniform image2D back_a;
layout(rgba32f, binding = 2) uniform image2D front_a;
layout(rgba32f, binding = 3) uniform image2D back_b;
layout(rgba32f, binding = 4) uniform image2D front_b;
layout(rgba32f, binding = 5) uniform image2D back_c;
layout(rgba32f, binding = 6) uniform image2D front_c;

layout(binding = 1) uniform timer { float seconds; };

/* BUFFERS */

layout(std430, binding = 2) buffer random { uint random_seed[]; };

layout(std430, binding = 3) buffer pcm_data {
    int pcm_samples;
    int sample_index;
    // `pcm` contains `2 * pcm_samples` entries.
    // These are the left channel values followed by the right channel values.
    float pcm[];
};

layout(std430, binding = 4) buffer dft_data {
    int dft_size;
    // `dft` contains `dft_size` entries.
    // Both raw and smooth sections follow the same pattern:
    // First come `dft_size / 2 + 1` real values.
    // Then come the `dft_size / 2 - 1` imaginary values in reverse, starting at
    // `dft_size / 2 - 1` (for even sizes). There is no imaginary part for the
    // first and last value.
    float dft[];
};

struct BandData {
    float accumulated;
    float window;
    float smooth_window;
    float avg_delta2;
    float movement;
    float other1, other2, other3;
};

layout(std430, binding = 5) buffer analysis_data {
    bool is_beat;
    int beats;
    int bpm;
    int other;

    BandData sub_bass;
    BandData bass;
    BandData lower_midrange;
    BandData midrange;
    BandData higher_midrange;
    BandData presence;
    BandData brilliance;
};

/* RANDOM */

uint pcg(uint v) {
    uint state = v * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float random_float(void) {
    int x = int(gl_GlobalInvocationID.x);
    int y = int(gl_GlobalInvocationID.y);
    int seed_index = y * int(gl_NumWorkGroups.x) + x;

    uint res = pcg(random_seed[seed_index]);
    random_seed[seed_index] = res;

    return abs(float(res) / float(1 << 31));
}

/* UTILITY */

float E = 2.71828182845904523536028;
float PI = 3.14159265358979323846264;

/**
 * Get average pixel at `pos` in the previous frame.
 */
vec3 read_a_at(vec2 pos) {
    ivec2 base = ivec2(floor(pos));
    vec3 ll = imageLoad(front_a, base + ivec2(0)).rgb;
    vec3 lu = imageLoad(front_a, base + ivec2(0, 1)).rgb;
    vec3 ul = imageLoad(front_a, base + ivec2(1, 0)).rgb;
    vec3 uu = imageLoad(front_a, base + ivec2(1)).rgb;

    vec2 fract = fract(pos);

    vec3 l = mix(ll, lu, fract.y);
    vec3 u = mix(ul, uu, fract.y);
    return mix(l, u, fract.x);
}

vec2 dft_at(int index) { return vec2(dft[index], index == 0 || index == (dft_size / 2) ? 0.0 : dft[dft_size - index]); }

mat2x2 rotate_matrix(float angle) { return mat2x2(vec2(cos(angle), sin(angle)), vec2(-sin(angle), cos(angle))); }

vec2 rotate(vec2 center, float a, vec2 x) {
    vec2 rel_x = x - center;
    return center + rotate_matrix(a) * rel_x;
}

vec2 scale(vec2 center, float a, vec2 x) { return center + (x - center) * a; }

vec3 color(float x) {
    return vec3(sin(x), sin(x + 3.1415 * 2.0 / 3.0), sin(x + 3.1415 * 4.0 / 3.0)); //  / 2.0 + 0.5;
}

/**
 * `x == 1` - 100% noize.
 */
float noize(float x) { return random_float() < x ? random_float() : 0.0; }

vec2 sin2(float factor, float scale_x, float scale_y) { return vec2(sin(scale_x * factor), sin(scale_y * factor)); }

/* ORRRRRBBB */

/**
 * Compute the brightness of an orb with `radius` radius,
 * located at `orb_position` as viewed from pixel `pixel_position`.
 */
float orb(vec2 pixel_position, vec2 orb_position, float radius) {
    // For reference see:
    // https://www.wolframalpha.com/input?i=e+%5E+-%28x*2.5%29%5E2+%3D+0.001
    vec2 delta = 2.5 * (pixel_position - orb_position) / radius;
    return pow(E, -dot(delta, delta));
}

vec3 make_orb(float offset_factor, float movement_factor, float vibro_factor, float radius, float color_offset,
              vec2 pixel, vec2 image) {
    vec2 global_center = 0.5 * image;

    vec2 pos = vec2(0);

    vec2 global_offset = sin2(offset_factor, 0.8457687721, 1.030459867);
    vec2 center = global_center + global_offset * 0.2 * image;
    vec2 avail_image = min(center, image - center) * 2;

    pos += center;

    vec2 base_offset = sin2(movement_factor, 1.4985372301, 1.0123120123);

    pos += 0.3 * avail_image * base_offset;

    vec2 local_offset = sin2(seconds + vibro_factor, 1.238746, 1.5867612);

    /* pos += 0.05 *  min(avail_image.x, avail_image.y) * local_offset; */

    vec3 color = color(color_offset);

    return orb(pixel, pos, radius) * color;
}

vec3 low_band_data_orb(BandData band, vec2 pixel, vec2 image) {
    float offset_factor = 0.2 * seconds + band.accumulated * 0.00001;
    float movement_factor = 0.001 * band.movement;
    float vibro_factor = 0.2 * band.avg_delta2;
    float radius = clamp(4 + 0.2 * band.window + 5 * sin(seconds), 3, 200);
    float color_offset = 0.00005 * band.accumulated;

    return make_orb(offset_factor, movement_factor, vibro_factor, radius, color_offset, pixel, image);
}

vec3 high_band_data_orb(BandData band, vec2 pixel, vec2 image) {
    float offset_factor = 0.2 * seconds + band.accumulated * 0.0000001;
    float movement_factor = 0.0003 * band.movement;
    float vibro_factor = 0.2 * band.avg_delta2;
    float radius = clamp(4 + 0.3 * band.window + 5 * sin(seconds), 3, 200);
    float color_offset = 0.0001 * band.accumulated;

    return make_orb(offset_factor, movement_factor, vibro_factor, radius, color_offset, pixel, image);
}

/* EFFECTS */

vec3 effect_frame(vec2 pixel, vec2 image) {
    vec2 img_half = image * 0.5;
    vec2 delta = abs(abs(pixel - img_half) - img_half);
    bool at_border = delta.x < 4 || delta.y < 4;
    return at_border && is_beat ? color(float(beats) * 2 * 3.1415 * 0.3333) : vec3(0);
}

vec3 effect_transform_prev_a(vec2 pixel, vec2 image) {
    vec2 center = image / 2;

    float movement = lower_midrange.smooth_window + midrange.smooth_window + higher_midrange.smooth_window;
    movement = -movement;
    // TRY THIS!
    /* float movement = lower_midrange.smooth_window / higher_midrange.smooth_window; */

    /* float scale_by = 1 + sin(seconds * 0.1) / 200; */
    float scale_by = 1.0 + -0.00001 * movement;
    vec2 scale_at = center + 0.75 * center * vec2(sin(seconds * 0.236745), sin(seconds * 0.278346));
    vec2 scaled = scale(scale_at, scale_by, pixel);

    float rotate_by = 0.003 * sin(seconds * 0.10234345);
    vec2 rotate_at = center + 0.75 * center * vec2(sin(seconds * 0.48765), sin(seconds * 0.894765));
    vec2 rotated = rotate(rotate_at, rotate_by, scaled);

    vec2 transform_by = 5 * vec2(sin(seconds / 6.1), sin(seconds / 5.7212));
    vec2 transformed = rotated + transform_by;

    float damping = 0.99;
    return damping * read_a_at(transformed);
}

vec3 effect_frequency_orbs_low(vec2 pixel, vec2 image) {
    return (low_band_data_orb(sub_bass, pixel, image) + low_band_data_orb(bass, pixel, image) +
            low_band_data_orb(lower_midrange, pixel, image));
}

vec3 effect_frequency_orbs_high(vec2 pixel, vec2 image) {
    return (high_band_data_orb(midrange, pixel, image) + high_band_data_orb(higher_midrange, pixel, image) +
            high_band_data_orb(presence, pixel, image) + high_band_data_orb(brilliance, pixel, image));
}

vec3 effect_high_noize() {
    vec3 noize_presence = noize(0.00001 * presence.window) * color(seconds * 0.1413);
    vec3 noize_brilliance = noize(0.00001 * brilliance.window) * color(seconds * 0.09384756);
    return noize_presence + noize_brilliance;
}

/* MAIN */

/* vec3 visualizer_front(ivec2 ipixel, ivec2 iimage) { */
/*     vec3 result = vec3(0); */
/*  */
/*     #<{(| vec3 transform_prev = effect_transform_prev(pixel, image); |)}># */
/*     #<{(| result += transform_prev; |)}># */
/*  */
/*     vec3 frequency_orbs = effect_frequency_orbs_front(pixel, image); */
/*     result += frequency_orbs; */
/*  */
/*     #<{(| vec3 high_noize = effect_high_noize(pixel); |)}># */
/*     #<{(| result += high_noize; |)}># */
/*  */
/*     vec3 frame = effect_frame(pixel, image); */
/*     result += frame; */
/*  */
/*     return clamp(result, 0, 1); */
/* } */

void main() {
    ivec2 ipixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 iimage = ivec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);

    vec2 pixel = vec2(ipixel);
    vec2 image = vec2(iimage);
    vec2 center = image / 2;

    // Rotate prev a
    vec3 transform_prev = effect_transform_prev_a(pixel, image);
    // Low freq ors.
    vec3 frequency_orbs = effect_frequency_orbs_low(pixel, image);
    // High noize.
    vec3 high_noize = effect_high_noize();
    // Beat frame.
    vec3 frame = effect_frame(pixel, image);
    imageStore(back_a, ipixel, vec4(frame + transform_prev + frequency_orbs + high_noize, 1));

    /* vec3 pixel_back_2 = imageLoad(back_b, iimage - ipixel - ivec2(1)).xyz; */
    /* imageStore(back_b, ipixel, vec4(frame + pixel_back_2, 1)); */

    // High freq orbs to texture C.
    vec3 frequency_orbs_high = effect_frequency_orbs_high(pixel, image);
    imageStore(back_c, ipixel, vec4(frequency_orbs_high, 1));
}
