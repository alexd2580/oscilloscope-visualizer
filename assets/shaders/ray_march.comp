#version 450

/* #extension GL_NV_gpu_shader5 : enable */
/* #extension GL_ARB_gpu_shader_int64 : enable */

/* UNIFORMS */

// Define a work group size to be 1x1.
layout(local_size_x = 8, local_size_y = 8) in;

// Use the image2D sampler to address specific pixels directly.
layout(rgba32f, binding = 0) uniform image2D present;
layout(rgba32f, binding = 1) uniform image2D back_a;
layout(rgba32f, binding = 2) uniform image2D front_a;
layout(rgba32f, binding = 3) uniform image2D back_b;
layout(rgba32f, binding = 4) uniform image2D front_b;
layout(rgba32f, binding = 5) uniform image2D back_c;
layout(rgba32f, binding = 6) uniform image2D front_c;

layout(binding = 1) uniform timer { float seconds; };

/* BUFFERS */

layout(std430, binding = 2) buffer random { uint random_seed[]; };

layout(std430, binding = 3) buffer pcm_data {
    int pcm_samples;
    int sample_index;
    // `pcm` contains `2 * pcm_samples` entries.
    // These are the left channel values followed by the right channel values.
    float pcm[];
};

layout(std430, binding = 4) buffer dft_data {
    int dft_size;
    // `dft` contains `dft_size` entries.
    // Both raw and smooth sections follow the same pattern:
    // First come `dft_size / 2 + 1` real values.
    // Then come the `dft_size / 2 - 1` imaginary values in reverse, starting at
    // `dft_size / 2 - 1` (for even sizes). There is no imaginary part for the
    // first and last value.
    float dft[];
};

struct BandData {
    float accumulated;
    float window;
    float smooth_window;
    float avg_delta2;
    float movement;
    float other1, other2, other3;
};

layout(std430, binding = 5) buffer analysis_data {
    bool is_beat;
    int beats;
    int bpm;
    int other;

    BandData sub_bass;
    BandData bass;
    BandData lower_midrange;
    BandData midrange;
    BandData higher_midrange;
    BandData presence;
    BandData brilliance;
};

/* RANDOM */

uint pcg(uint v) {
    uint state = v * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float random_float(void) {
    int x = int(gl_GlobalInvocationID.x);
    int y = int(gl_GlobalInvocationID.y);
    int seed_index = y * int(gl_NumWorkGroups.x) + x;

    uint res = pcg(random_seed[seed_index]);
    random_seed[seed_index] = res;

    return abs(float(res) / float(1 << 31));
}

/* UTIL */
float E = 2.71828182845904523536028;
float PI = 3.14159265358979323846264;

vec3 color(float x) {
    return clamp(vec3(sin(x), sin(x + 3.1415 * 2.0 / 3.0), sin(x + 3.1415 * 4.0 / 3.0)), 0, 1); //  / 2.0 + 0.5;
}

/* RAY MARCHING */

float maxcomp(vec3 vec) {
    return max(vec.x, max(vec.y, vec.z));
}

/* SDF */

float sdf_sphere(vec3 pos, float radius) {
    return length(pos) - radius;
}

float sdf_cube(vec3 pos, float side_len) {
    vec3 to_corner = abs(pos) - vec3(side_len / 2);
    return length(max(to_corner, 0)) + min(maxcomp(to_corner), 0);
}

float sdf_box(vec3 pos, vec3 side_len) {
    vec3 to_corner = abs(pos) - side_len / 2;
    return length(max(to_corner, 0)) + min(maxcomp(to_corner), 0);
}

float sdf_cylinder(vec3 pos, float radius) {
    return length(pos.yz) - radius;
}
float sdf_plane(vec3 pos, vec3 normal, float offset) {
    return abs(pos.y - offset);
}

float sdf_x_plane(vec3 pos, float offset) {
    return abs(pos.x - offset);
}

float sdf_y_plane(vec3 pos, float offset) {
    return abs(pos.y - offset);
}

float sdf_z_plane(vec3 pos, float offset) {
    return abs(pos.z - offset);
}

float sdf_subtract(float a, float b) {
    return max(a, -b);
}

float sdf_union(float a, float b) {
    return min(a, b);
}

float sdf_intersect(float a, float b) {
    return max(a, b);
}

float sdf_union_4(float a, float b, float c, float d) {
    return min(min(a, b), min(c, d));
}

// Position functions.

mat3 rotation_matrix(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c       );
}

vec3 scale_inv(vec3 pos, vec3 scale) {
    return pos * scale;
}

vec3 at(vec3 pos, vec3 o) {
    return pos - o;
}

vec3 rotated(vec3 pos, vec3 axis, float angle) {
    return rotation_matrix(axis, angle) * pos;

}

vec3 repeat_pos(vec3 pos, vec3 size_repeat) {
    return mod(pos + size_repeat * 0.5, size_repeat) - size_repeat * 0.5;
}

vec3 repeat_pos_int(vec3 pos, vec3 size_repeat, vec3 num_repeat) {
    vec3 wrapd = repeat_pos(pos, size_repeat);
    vec3 num_repeated = (pos - wrapd) / size_repeat;
    vec3 surplus_wraps = min(num_repeated + num_repeat, 0) + max(num_repeated - num_repeat, 0);
    return wrapd + surplus_wraps * size_repeat;
}

float sdf_scene(vec3 pos) {
    float top = sdf_y_plane(pos, 0.0);
    float bot = sdf_y_plane(pos, 2.4);
    float y_walls = sdf_union(top, bot);

    float left = sdf_x_plane(pos, 1.5);
    float right = sdf_x_plane(pos, -1.5);
    float x_walls = sdf_union(left, right);

    vec3 doorway_size = vec3(0.8, 2.0, 0.05);
    float doorway = sdf_box(at(pos, vec3(0.9, 1.0, 1.5)), doorway_size);

    float back = sdf_z_plane(pos, 1.5);
    back = sdf_subtract(back, doorway);
    float front = sdf_z_plane(pos, -1.5);
    float z_walls = sdf_union(front, back);

    float room = sdf_union(y_walls, sdf_union(x_walls, z_walls));

    vec3 table_pos = vec3(-0.55, 1.0, 1.05);
    vec3 table_size = vec3(1.8, 0.02, 0.8);
    float table_surface = sdf_box(at(pos, table_pos), table_size);

    vec3 size_32 = vec3(0.7, 0.4, 0.01);
    vec3 mon_1_pos = at(pos, vec3(-0.07, 1.3, 1.3));
    vec3 mon_1_rot = rotated(mon_1_pos, vec3(0, 1, 0), PI / 8);
    float mon_1 = sdf_box(mon_1_rot, size_32);
    vec3 mon_2_pos = vec3(-0.79, 1.3, 1.4);
    float mon_2 = sdf_box(at(pos, mon_2_pos), size_32);

    vec3 size_24 = vec3(0.35, 0.65, 0.02);
    vec3 mon_3_pos = at(pos, table_pos + vec3(-0.75, size_24.y / 2 + 0.01, 0.2));
    vec3 mon_3_rot = rotated(mon_3_pos, vec3(0, 1, 0), -PI / 4);
    float mon_3 = sdf_box(mon_3_rot, size_24);

    float table = sdf_union_4(table_surface, mon_1, mon_2, mon_3);


    /* float sphere = sdf_sphere(at(pos, vec3(0, 0.5, 3)), 0.5); */
    /* float cylinder = sdf_sphere(at(pos, vec3(1, 0.9, 4)), 0.5); */

    return sdf_union(room, table);
}

vec3 normal_scene(vec3 pos) {
    const float eps = 0.1;
    const vec2 h = vec2(eps, 0);
    float dx = sdf_scene(pos + h.xyy) - sdf_scene(pos - h.xyy);
    float dy = sdf_scene(pos + h.yxy) - sdf_scene(pos - h.yxy);
    float dz = sdf_scene(pos + h.yyx) - sdf_scene(pos - h.yyx);
    return normalize(vec3(dx, dy, dz));
}

/* MAIN */

struct Hit {
    vec3 point;
    int steps;
    float remaining_dist;
};

Hit ray_march(vec3 ray_origin, vec3 ray_dir) {
    int num_steps = 50;
    for (int i=0; i < num_steps; i++) {
        float distance_scene = sdf_scene(ray_origin);
        if (distance_scene < 0.01) {
            return Hit(ray_origin, i, distance_scene);
        }
        ray_origin += distance_scene * ray_dir;
    }
    return Hit(vec3(1.0 / 0.0), -1, 1.0 / 0.0);
}

vec3 lighting(Hit hit) {
    vec3 ambient = vec3(0.2);
    vec3 normal = normal_scene(hit.point);
    vec3 diffuse = color(midrange.movement / 1000) * dot(normal, vec3(0, 1, 0));
    float fake_ssao_or_whatever = pow((75 - float(hit.steps)) / 100, 2);
    return fake_ssao_or_whatever * vec3(1);
    return fake_ssao_or_whatever * ambient + diffuse;
    /* float dist = length(point - vec3(0, 0, 0)); */
    /* return  * vec3(clamp(5 - dist, 0, 5) / 5); */
}

void main() {
    ivec2 ipixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 iimage = ivec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);

    vec2 uv = 2 * vec2(ipixel) / vec2(iimage) - 1;

    float aspect_ratio = float(iimage.x) / float(iimage.y);
    float fovy  = 2 * PI / 3;
    float fov_factor = tan(fovy / 2);

    vec3 ray_origin = vec3(0, 1.8, 0);
    vec3 camera_ahead = vec3(0, 0, 1);
    vec3 camera_right = vec3(-1, 0, 0);
    vec3 camera_up = vec3(0, 1, 0);

    camera_ahead = vec3(cos(seconds), 0, sin(seconds));
    camera_right = vec3(-sin(seconds), 0, cos(seconds));

    ray_origin -= 1.4 * camera_ahead;

    /* ray_origin = vec3(-1, 2.3, 1.2); */
    /* camera_ahead = vec3(0, -1, 0); */
    /* camera_right = vec3(-1, 0, 0); */
    /* camera_up = vec3(0, 0, 1); */

    vec3 ray_dir = normalize(camera_ahead + fov_factor * (uv.x * aspect_ratio * camera_right + uv.y * camera_up));

    Hit hit = ray_march(ray_origin, ray_dir);
    vec3 color = lighting(hit);

    imageStore(present, ipixel, vec4(color, 1));
}
